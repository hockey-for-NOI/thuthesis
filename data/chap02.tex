\chapter{耦合模式分量适配}
\label{cha:refactor}

\section{结构介绍}

CESM 的各个模式分量由不同研究方向的科学家、工作人员以及部分社区开发人员编写，其代码结构和风格具有较大差异。出于适配和后续调试考虑，我们希望将这些代码尽可能在适配后拥有共通的编译结构、相似的代码结构和对调试工具的较好适应性。为此，我们需要对各个模式分量的代码实现进行分析和调整。

\subsection{cam}

cam 模式分量实现是在各个耦合实验中最为广泛使用的模式分量实现，也是对耦合框架的主要需求方。在 cam 的代码内部内嵌了足以自行抽取其他模式分量实现独立编译为一个完整耦合实验的代码，这使得 cam 内部实质上包含了顶层耦合框架提供的所有功能的下位或等位替代，可以作为耦合框架编写和调整的参考。然而，在我们的隔离设计中并不希望单个耦合模式分量需要考虑独立获取其他所需的模式分量实现所需信息，直至编译整个耦合实验。因此，我们最终封装后的模式分量实现需要把这部分内嵌依赖和编译代码移除，在必要的部分插入顶层耦合框架作为插件，其他部分则以脚本等形式进行存档或直接单独封装为独立的外部库。

bld 目录存放了上述需求获取和全面编译的代码。这些脚本大部分采用 csh (C-shell, https://en.wikipedia.org/wiki/C\_Shell) 和 perl (http://www.perl.org/) 语言进行执行，其依赖库直接放在了该目录下的 perl5lib 子目录中，配置文件则位于 config\_files 子目录下并以 xml 文件的形式存放。这些配置文件和脚本涉及了各个预置编译平台、各个预置耦合实验的分辨率、各个模块版本和内置物理参数等信息，还包括依赖的各个直接或间接连接的模式分量实现所需的配置信息。在编译完成后， build-namelist 脚本负责基于编译依赖信息和预置配置文件生成一套运行时配置文件，这种结构可以减少在不同模式下切换时带来的不必要的重复编译环节。在我们重构和适配后的版本中，这些运行时配置文件将会由顶层耦合框架生成，但考虑到各个模式分量实现读取的运行时配置格式不尽相同，这里需要将 build-namelist 代码重构为一个读取来自于顶层耦合框架的配置文件并将其格式转变为对应耦合模式分量实现代码运行时可读格式的配置文件。实际上，在该工作完成后，我们鼓励新的耦合模式分量实现都按照预设的顶层耦合框架配置文件进行读取的设计，这样可以直接跳过生成 namelist 运行时配置的步骤以达到简化适配流程的结果。为此，顶层耦合框架配置文件应当具有足够的适应性并能够提取各个模式分量中的共同配置进行同步以防止数据不匹配等问题。另外，考虑到整个模式分量实现的代码均由 fortran 代码构成， python 部分仅参与代码生成部分而不接触实际运行，这里的配置文件采用 fortran 语言内置的 namelist 格式。该格式是一种人类可读的类字典复合格式，具有相当的适配性和可读性，易于调试。其缺点在于运行时配置的读取较二进制文件较慢且难以并行，但考虑到目前耦合模式分量的运行时配置相对较少，实际进行速度测试时该部分效率影响可以忽略不计，故暂时维持 CESM 设定的格式。未来若存在接入 C 或 C++ 等其他语言代码需求则可以考虑采用更加效率重视型的 NetCDF 文件甚至直接通过 protobuf (Google Protocol Buffer, https://developers.google.com/protocol-buffers/)进行在线的数据传输。该目录还存放编译过程中产生的中间结果以支持基于 Makefile 的增量编译等特性。

chem\_proc 目录存放与化学过程插件相关的源代码及独立测试框架。化学过程插件是在社区中被提出的一个专门处理大气模式中涉及到的纯化学和化学相关过程的插件，自身具有独立的公式体系并可以单独进行编译和运行。其调试过程将预置的接口参数作为输入从文件中读取，运行化学过程后将输出写入文件中并通过脚本进行外部读取从而和观测数据进行对比从而确认代码正确性。实际与 cam 共同编译时，输入输出部分被移除，成为一个独立的内部库与 cam 源码一起编译。这种分阶段调试的方式可以极大地降低错误定位难度，我们在其他的模式分量实现中也会看到类似的处理方法。但相对的，这种方法需要对实际物理数据进行分析处理以获取该化学过程需要的输入输出数据，因此需要相应的气候地理学家的支持。对于从纯代码角度进行封装和适配的角度来说，由于代码隔离的过程中需要生成中间数据，因此数据的正确性对另一部分代码存在依赖，因而不能完全隔离两部分代码的正确性。从结果上看，在封装的过程中我们只保留了原有的代码隔离模块，并没有再对耦合模式分量实现中的已有代码进行拆分解耦。

src 目录存放了 cam 主要部分的全部源码。这部分源码的内部依赖较为复杂且难以拆分，因此我们选择将其作为黑盒进行处理。这里 cam 的对外接口主要是 cpl\_esmf 、 cpl\_mct 、 cpl\_share 三个目录，其中由于我们采用了 MCT 作为基本数据结构，因此主要接口为 cpl\_mct 目录下的 atm\_comp\_mct.F90 文件。 cpl\_share 目录提供了 MCT 数据结构的域定义和编号缓存，以减小多进程高频率的数据结构访问下带来的字符串操作对应延迟，最大化运行效率。这两个目录是我们封装过程中主要需要处理的部分。另外，代码各个涉及到错误处理的部分都要求与顶层耦合调试工具进行对接，因此还涉及数个需要调整的代码段。在针对 cam 模块进行的错误定位时，通常可以通过在内部控制模块 control 设置断点来进行大致定位并进一步调试。

test 目录提供了一套以 cam 为中心进行单元测试的模块，其测试范围包括 cam 独立运行和各种包含 cam 的耦合试验测试。由于我们对接口进行了适配修改，因此将 cam 作为整体的测试（包括对 cam 的封装级测试和对于带 cam 的外部耦合试验实例整体测试）由于接口发生变化而需要修改或直接放弃而无法运行，但针对 cam 各个内部模块的小规模测试依然成立，可以防止进行嵌入式修改后造成的数值不匹配或计算逻辑错误。

tools 目录提供了一些辅助调试的工具，主要用于不同格式的输入文件和数据文件之间的互相转换。顶层耦合中的部分代码和工具参考了这部分代码并进行了对各个模式分量的适配使得他们可以用于全部的模式分量实现中的格式转换。

总体上来看， cam 的代码结构是所有模式分量实现中较为复杂的一个。出于适配效率考虑我们并没有完整地分析其中的具体结构细节或是实现细节，而是尽可能将其作为一个可编译运行的整体来进行封装和适配来尽可能在保证其正确性和完整性的情况下减少适配工作量。值得一提的是，由于 cam 部分结构并不具有普适性且复杂度偏高，我们并没有采用该结构作为适配后的结构，而是参考了之后更为简洁和标准化的模式分量结构。在 cam 的适配过程中向目标结构进行了一定的修改的同时保留了 cam 部分框架特点以尽可能为 cam 模式分量实现的更新版适配做准备。

