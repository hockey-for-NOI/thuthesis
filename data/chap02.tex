\chapter{耦合模式分量适配}
\label{cha:refactor}

\section{结构介绍}

CESM 的各个模式分量由不同研究方向的科学家、工作人员以及部分社区开发人员编写，其代码结构和风格具有较大差异。出于适配和后续调试考虑，我们希望将这些代码尽可能在适配后拥有共通的编译结构、相似的代码结构和对调试工具的较好适应性。为此，我们需要对各个模式分量的代码实现进行分析和调整。

\subsection{cam}

cam 是模式分量 atm 的一种实现。该模式分量实现是在各个耦合实验中最为广泛使用的模式分量实现，也是对耦合框架的主要需求方。在 cam 的代码内部内嵌了足以自行抽取其他模式分量实现独立编译为一个完整耦合实验的代码，这使得 cam 内部实质上包含了顶层耦合框架提供的所有功能的下位或等位替代，可以作为耦合框架编写和调整的参考。然而，在我们的隔离设计中并不希望单个耦合模式分量需要考虑独立获取其他所需的模式分量实现所需信息，直至编译整个耦合实验。因此，我们最终封装后的模式分量实现需要把这部分内嵌依赖和编译代码移除，在必要的部分插入顶层耦合框架作为插件，其他部分则以脚本等形式进行存档或直接单独封装为独立的外部库。

bld 目录存放了上述需求获取和全面编译的代码。这些脚本大部分采用 csh (C-shell, https://en.wikipedia.org/wiki/C\_Shell) 和 perl (http://www.perl.org/) 语言进行执行，其依赖库直接放在了该目录下的 perl5lib 子目录中，配置文件则位于 config\_files 子目录下并以 xml 文件的形式存放。这些配置文件和脚本涉及了各个预置编译平台、各个预置耦合实验的分辨率、各个模块版本和内置物理参数等信息，还包括依赖的各个直接或间接连接的模式分量实现所需的配置信息。在编译完成后， build-namelist 脚本负责基于编译依赖信息和预置配置文件生成一套运行时配置文件，这种结构可以减少在不同模式下切换时带来的不必要的重复编译环节。在我们重构和适配后的版本中，这些运行时配置文件将会由顶层耦合框架生成，但考虑到各个模式分量实现读取的运行时配置格式不尽相同，这里需要将 build-namelist 代码重构为一个读取来自于顶层耦合框架的配置文件并将其格式转变为对应耦合模式分量实现代码运行时可读格式的配置文件。实际上，在该工作完成后，我们鼓励新的耦合模式分量实现都按照预设的顶层耦合框架配置文件进行读取的设计，这样可以直接跳过生成 namelist 运行时配置的步骤以达到简化适配流程的结果。为此，顶层耦合框架配置文件应当具有足够的适应性并能够提取各个模式分量中的共同配置进行同步以防止数据不匹配等问题。另外，考虑到整个模式分量实现的代码均由 fortran 代码构成， python 部分仅参与代码生成部分而不接触实际运行，这里的配置文件采用 fortran 语言内置的 namelist 格式。该格式是一种人类可读的类字典复合格式，具有相当的适配性和可读性，易于调试。其缺点在于运行时配置的读取较二进制文件较慢且难以并行，但考虑到目前耦合模式分量的运行时配置相对较少，实际进行速度测试时该部分效率影响可以忽略不计，故暂时维持 CESM 设定的格式。未来若存在接入 C 或 C++ 等其他语言代码需求则可以考虑采用更加效率重视型的 NetCDF 文件甚至直接通过 protobuf (Google Protocol Buffer, https://developers.google.com/protocol-buffers/)进行在线的数据传输。该目录还存放编译过程中产生的中间结果以支持基于 Makefile 的增量编译等特性。

chem\_proc 目录存放与化学过程插件相关的源代码及独立测试框架。化学过程插件是在社区中被提出的一个专门处理大气模式中涉及到的纯化学和化学相关过程的插件，自身具有独立的公式体系并可以单独进行编译和运行。其调试过程将预置的接口参数作为输入从文件中读取，运行化学过程后将输出写入文件中并通过脚本进行外部读取从而和观测数据进行对比从而确认代码正确性。实际与 cam 共同编译时，输入输出部分被移除，成为一个独立的内部库与 cam 源码一起编译。这种分阶段调试的方式可以极大地降低错误定位难度，我们在其他的模式分量实现中也会看到类似的处理方法。但相对的，这种方法需要对实际物理数据进行分析处理以获取该化学过程需要的输入输出数据，因此需要相应的气候地理学家的支持。对于从纯代码角度进行封装和适配的角度来说，由于代码隔离的过程中需要生成中间数据，因此数据的正确性对另一部分代码存在依赖，因而不能完全隔离两部分代码的正确性。从结果上看，在封装的过程中我们只保留了原有的代码隔离模块，并没有再对耦合模式分量实现中的已有代码进行拆分解耦。

src 目录存放了 cam 主要部分的全部源码。这部分源码的内部依赖较为复杂且难以拆分，因此我们选择将其作为黑盒进行处理。这里 cam 的对外接口主要是 cpl\_esmf 、 cpl\_mct 、 cpl\_share 三个目录，其中由于我们采用了 MCT 作为基本数据结构，因此主要接口为 cpl\_mct 目录下的 atm\_comp\_mct.F90 文件。 cpl\_share 目录提供了 MCT 数据结构的域定义和编号缓存，以减小多进程高频率的数据结构访问下带来的字符串操作对应延迟，最大化运行效率。这两个目录是我们封装过程中主要需要处理的部分。另外，代码各个涉及到错误处理的部分都要求与顶层耦合调试工具进行对接，因此还涉及数个需要调整的代码段。在针对 cam 模块进行的错误定位时，通常可以通过在内部控制模块 control 设置断点来进行大致定位并进一步调试。

test 目录提供了一套以 cam 为中心进行单元测试的模块，其测试范围包括 cam 独立运行和各种包含 cam 的耦合试验测试。由于我们对接口进行了适配修改，因此将 cam 作为整体的测试（包括对 cam 的封装级测试和对于带 cam 的外部耦合试验实例整体测试）由于接口发生变化而需要修改或直接放弃而无法运行，但针对 cam 各个内部模块的小规模测试依然成立，可以防止进行嵌入式修改后造成的数值不匹配或计算逻辑错误。

tools 目录提供了一些辅助调试的工具，主要用于不同格式的输入文件和数据文件之间的互相转换。顶层耦合中的部分代码和工具参考了这部分代码并进行了对各个模式分量的适配使得他们可以用于全部的模式分量实现中的格式转换。

总体上来看， cam 的代码结构是所有模式分量实现中较为复杂的一个。出于适配效率考虑我们并没有完整地分析其中的具体结构细节或是实现细节，而是尽可能将其作为一个可编译运行的整体来进行封装和适配来尽可能在保证其正确性和完整性的情况下减少适配工作量。值得一提的是，由于 cam 部分结构并不具有普适性且复杂度偏高，我们并没有采用该结构作为适配后的结构，而是参考了之后更为简洁和标准化的模式分量结构。在 cam 的适配过程中向目标结构进行了一定的修改的同时保留了 cam 部分框架特点以尽可能为 cam 模式分量实现的更新版适配做准备。

\subsection{pop2}

pop2 是海洋模式分量 ocn 的一个实现。该模式分量实现并不包含于我们要复现的 F2000 实验中，但其结构为我们进行其他模式分量封装提供了很大帮助，因此这里着重介绍一下 pop2 模式分量实现的结构。

与 cam 类似，pop2 提供了 bld 目录作为基于 csh 和 perl 脚本语言的共通编译框架，其内部结构与 cam 类似但更精简，且与我们的适配关系不大，在此不再赘述。但 pop2 模式分量实现在编写时还提供了另一套独立的自编译框架，该框架位于 build 目录下，并可以在没有外部依赖的情况下独立完成对 pop2 源代码的编译。这种编译框架能够极大的方便适配过程中进行的隔离编译和隔离调试，因此我们以该目录为模板对所有涉及的模式分量进行了附加自编译模块。特别的，对于 cam 模式分量来说，其编译系统较为复杂，直接插入附加自编译模块导致了部分冲突和重复编译，因此我们只对 cam 模式分量进行了特殊适配，保留了其原有的编译系统的基础上，将删减过的自编译模块以脚本调用的形式附加，从而保证了编译效率和正确性。

build 目录下提供了大量配置文件以在各个预设实验平台下编译。由于我们的实验平台并非预设平台，因此要对这些配置文件进行修改。我们选择了与实验平台较为接近的 linux 配置并对其进行了针对实验平台的改动，包括修改 NetCDF 等依赖库的配置路径，将顶层耦合模块提供的预设配置插入编译选项，设置 mpi 等依赖库的配置开关等。特别需要注意的是，耦合模式分量实现本身没有 C/C++ 代码，但这里必须要对 C++ 编译器进行配置，原因是 fortran 编译器处理部分宏存在问题，需要用 C++ 编译器进行不编译只展开宏的处理，并将处理后的代码放置在 compile 目录下再用 fortran 编译器进行整体编译。另外，默认配置下 fortran 编译器不具有多进程功能，而整个耦合实验必须在 mpi 的多进程模式下进行运行。因此这里编译器需要改为 mpif90 并可以将与单线程 mpi 相关的 mpi-serial 部分全部移除以提高编译效率。另外，当进行嵌入式调试时，调试信息可以被插入 compile 目录下宏展开后的代码以达成自动更新。该自编译模块的主要编译流程如下：

\begin{itemize}
  \item [1)] 
通过外部宏 ARCH 设定编译平台，载入对应的配置文件
  \item [2)]
通过外部宏 SRCDIR 和 EXEDIR 设定源码路径(通常为上级目录)和编译目标路径(通常为 build 目录本身)
  \item [3)]
调用 preprocess.mk 模块进行预编译，将所有找到的源码进行宏展开并放置到 compile 目录下
  \item [4)]
调用 depends.mk 和 fdepends.awk 生成编译所需的依赖
  \item [5)]
调用 compile.mk 依据所生成的依赖自动编译 compile 目录下的所有源码
  \item [6)]
将编译好的源码进行后续处理、打包并与顶层耦合平台对接
\end{itemize}

在上述步骤中，前两步的宏设置可以通过相对路径进行自动适配，因而可以自然应用到各个模式分量实现中。第三步预编译步骤会在若干指定目录下将所有找到的 fortran 代码全部进行宏展开，因此需要针对各个模式分量实现的路径框架进行修改。特别的，对于部分提供多种适配代码的模式分量实现(例如 pop2 同时提供了单进程和多进程的外部库，且他们的接口名称和格式都完全相同)，只能选择正确的版本进行预编译，否则会产生重名、冲突、适配错误等情况。预编译中，所有预设的宏都会被展开，因此可以在 compile 文件查看宏展开后的代码来确定是否所有的配置都被正确应用。第四部依赖自动生成设定上只考虑内部依赖，因此对于涉及的外部库 (包括顶层耦合提供的库函数和外部依赖库函数) 都需要在 fdepends.awk 文件进行注册(该文件是 linux 原生的字符串操作脚本语言 awk ，推荐使用 \href{https://www.gnu.org/software/gawk/manual/gawk.html#Getting-Started}{gawk} 进行运行)。生成的依赖文件将被放在 compile 目录的 depends 子目录下，并与第三部生成的宏展开后的代码一同进入第五步编译。这一步作为主要编译步骤，其所需的全部信息都在配置文件和之前的步骤准备完毕，因此可以进行全自动编译。在编译完成后，我们将编译生成的 .o 文件进行打包成为静态库，并将接口相关的 .mod 头文件自动传输至顶层耦合平台以备其他模块(主要是耦合代码核心模块 cpl )编译时使用。总体来说，只需要对平台进行一次配置和一次外部依赖配置，对各个模式分量实现进行代码框架目录设置，即可完成自动编译，因此该模块被我们作为耦合模式分量适配的主要模块来使用。

pop2 的主要代码实现部分由于并没有在 F2000 中使用，故略过不提。这里补充说明一些在 pop2 目录中可以被用来帮助其他模式分量实现进行封装或辅助调试的部分。 mpi 和 serial 目录分别对应多线程和单线程的 mpi 封装接口，在部分需要越过 MCT 层直接调用 mpi 进行操作的场合可以运用这些接口进行调用 (通常是用来调试)。 input\_templates 目录提供了各个分辨率的模板可以用于测试各种边界情况。 test 目录和 tools 目录提供了部分关于时间管理、历史记录和存储恢复的代码。实际上，各个模式分量实现的时间管理模块具有一定的相似性，因此我们提取了其中的共同部分，并加入了一些封装和额外功能作为顶层耦合模式的主时钟。这些代码都为顶层耦合实现的设计提供了参考。

\subsection{docn}

docn 是 ocn 模式分量的纯数据实现，也是 F2000 中唯一一个纯数据模式分量实现。顶层耦合模块的第一版耦合测试就是通过 cam 模块和该模块两个模式分量实现进行耦合完成的。其代码结构在所有的模式分量实现中最为简单，在封装中我们直接将其压缩为单个文件以最大程度上降低该模块可能产生的错误，从而把耦合模式分量调试集中到顶层耦合模块与 cam 模块之间的接口和数据交互中。

虽然核心代码只有一个文件，但作为一个完整的模式分量实现， docn 依然包含一套完整的模式分量实现结构：编译目录 bld ， 对两种耦合模式分量实现的接口 cpl\_mct 和 cpl\_esmf ，以及进行独立调试和输入输出的测试工具 tools 目录。值得一提的是， docn 的运行时配置文件 namelist 被拆分为 docn\_in 和 docn\_ocn\_in 两个文件，将专属于该模式分量实现的配置独立出来，以和其他 ocn 模式分量实现的运行时配置保持格式一致。另外，这里接口代码 cpl\_mct 的部分数据适配被移动到了核心代码 docn\_comp\_mod.F90 下，因此在适配过程中会与其他模式分量产生些许不同，我们会在下一章适配过程中详细描述这一部分。

总的来说，选择 docn 作为耦合实验实例的一部分不仅提供了更加简单和模块化的调试顶层耦合模块的流程，还为之后其他实验的纯数据模式分量适配提供了参照。

\subsection{clm}

clm 是 lnd 模式分量的一个实现。该模式分量的特点在于有 clm4\_0 和 clm4\_5 两个等位模块，这两部分分别适用于不同的耦合实验实例，因此需要在配置时进行分别配置。每个等位模块内部将物理、化学和主过程进行了分离。这里的 bld 目录在适配入 pop2 的 build 自编译模块后其编译功能可以被舍弃，从而只需保留生成运行时配置文件的代码。

在实际适配中， lnd 模式分量遇到的主要问题是网格化后的边界处不满一格进行的处理需要顶层耦合模块的 fraction 框架与模式分量进行适配(实际上 ocn 模式分量也有类似问题，但 docn 模式分量没有输入需求因此不需考虑这一点)。为此，在 cpl\_mct 中的 lnd\_domain\_mct 函数中需要直接对 fraction 代码进行修改，使其能够从顶层耦合模型的配置中读取原本从文件中输入的网格大小和网格比例数据。

\subsection{cice}

cice 是 ice 模式分量的一个实现。该模式分量比上述模式分量的实现较为简单且有较为详细的文档。与 clm 类似的，这里只保留 bld 目录下进行运行时配置文件 namelist 生成的部分代码，编译部分同样交给自编译模块 build 。代码目录 src 提供了 mpi 的单进程和多进程接口， driver 目录下的 cice4 提供了一套能够独立运行和调试 cice 自身的驱动接口，其中 init ， run ， final 分别对应于 driver 接口中的三个接口，而 history 和 restart 分别对应顶层耦合模式的主时钟模块的两个功能历史记录和存储恢复。这部分代码作为独立调试使用，在最终模式分量编译和封装时不加入编译的源码目录列表。

在 cice 模块的 cpl\_share 目录下存放了与 cice4 同名同接口不同实现的模块。这些模块移除了调试并加入了 NetCDF ， ParallelIO 等多进程/线程加速代码以提高运行效率。在实际开发中，可以在 cice4 接口进行调试通过后，将其同步到 cpl\_share 接口中以确保多线程代码的正确性，并将加速代码代替 cice4 进行完整的库编译以达成隔离调试和运行提速。如果最终编译出现问题，则需要检查替换的多进程部分是否会出现数据不匹配或 race condition 等问题。

总体来说， cice 作为一个结构较为简单的模式分量实现，其自带详细的文档和独立调试模块，使得其独立适配难度较低。事实上，cice 和 docn 两模块构成的简单耦合实验实例相较 cam 和 docn 的耦合实验实例从代码层面上更加适合对顶层耦合模式进行调试，但 ice 和 ocn 模式分量对 atm 模式的输出存在较多依赖，因此需要追加 datm 模块才能较好地保证模式分量的数值正确性和稳定性。考虑到 cam 的重要性，最终我们放弃了 cice 选择了 cam 和 docn 的耦合实验实例作为第一版顶层耦合模式测试。

\subsection{rtm}

rtm 是 rof 模式分量的一个实现。该