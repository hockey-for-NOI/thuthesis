\chapter{耦合模式分量适配}
\label{cha:refactor}

\section{结构介绍}

CESM 的各个模式分量由不同研究方向的科学家、工作人员以及部分社区开发人员编写，其代码结构和风格具有较大差异。出于适配和后续调试考虑，本文希望将这些代码尽可能在适配后拥有共通的编译结构、相似的代码结构和对调试工具的较好适应性。为此，本文需要对各个模式分量的代码实现进行分析和调整。

\subsection{cam}

cam \cite{CAMdoc}是模式分量 atm 的一种实现。该模式分量实现是在各个耦合实验中最为广泛使用的模式分量实现，也是对耦合框架的主要需求方。在 cam 的代码内部内嵌了足以自行抽取其他模式分量实现独立编译为一个完整耦合实验的代码，这使得 cam 内部实质上包含了顶层耦合框架提供的所有功能的下位或等位替代，可以作为耦合框架编写和调整的参考。然而，在本文的隔离设计中并不希望单个耦合模式分量需要考虑独立获取其他所需的模式分量实现所需信息，直至编译整个耦合实验。因此，本文最终封装后的模式分量实现需要把这部分内嵌依赖和编译代码移除，在必要的部分插入顶层耦合框架作为插件，其他部分则以脚本等形式进行存档或直接单独封装为独立的外部库。

bld 目录存放了上述需求获取和全面编译的代码。这些脚本大部分采用 csh (C-shell, https://en.wikipedia.org/wiki/C\_Shell) 和 perl (http://www.perl.org/) 语言进行执行，其依赖库直接放在了该目录下的 perl5lib 子目录中，配置文件则位于 config\_files 子目录下并以 xml 文件的形式存放。这些配置文件和脚本涉及了各个预置编译平台、各个预置耦合实验的分辨率、各个模块版本和内置物理参数等信息，还包括依赖的各个直接或间接连接的模式分量实现所需的配置信息。在编译完成后， build-namelist 脚本负责基于编译依赖信息和预置配置文件生成一套运行时配置文件，这种结构可以减少在不同模式下切换时带来的不必要的重复编译环节。在本文重构和适配后的版本中，这些运行时配置文件将会由顶层耦合框架生成，但考虑到各个模式分量实现读取的运行时配置格式不尽相同，这里需要将 build-namelist 代码重构为一个读取来自于顶层耦合框架的配置文件并将其格式转变为对应耦合模式分量实现代码运行时可读格式的配置文件。实际上，在该工作完成后，本文鼓励新的耦合模式分量实现都按照预设的顶层耦合框架配置文件进行读取的设计，这样可以直接跳过生成 namelist 运行时配置的步骤以达到简化适配流程的结果。为此，顶层耦合框架配置文件应当具有足够的适应性并能够提取各个模式分量中的共同配置进行同步以防止数据不匹配等问题。另外，考虑到整个模式分量实现的代码均由 fortran 代码构成， python 部分仅参与代码生成部分而不接触实际运行，这里的配置文件采用 fortran 语言内置的 namelist 格式。该格式是一种人类可读的类字典复合格式，具有相当的适配性和可读性，易于调试。其缺点在于运行时配置的读取较二进制文件较慢且难以并行，但考虑到目前耦合模式分量的运行时配置相对较少，实际进行速度测试时该部分效率影响可以忽略不计，故暂时维持 CESM 设定的格式。未来若存在接入 C 或 C++ 等其他语言代码需求则可以考虑采用更加效率重视型的 NetCDF 文件甚至直接通过 protobuf (Google Protocol Buffer, https://developers.google.com/protocol-buffers/)进行在线的数据传输。该目录还存放编译过程中产生的中间结果以支持基于 Makefile 的增量编译等特性。

chem\_proc 目录存放与化学过程插件相关的源代码及独立测试框架。化学过程插件是在社区中被提出的一个专门处理大气模式中涉及到的纯化学和化学相关过程的插件，自身具有独立的公式体系并可以单独进行编译和运行。其调试过程将预置的接口参数作为输入从文件中读取，运行化学过程后将输出写入文件中并通过脚本进行外部读取从而和观测数据进行对比从而确认代码正确性。实际与 cam 共同编译时，输入输出部分被移除，成为一个独立的内部库与 cam 源码一起编译。这种分阶段调试的方式可以极大地降低错误定位难度，本文在其他的模式分量实现中也会看到类似的处理方法。但相对的，这种方法需要对实际物理数据进行分析处理以获取该化学过程需要的输入输出数据，因此需要相应的气候地理学家的支持。对于从纯代码角度进行封装和适配的角度来说，由于代码隔离的过程中需要生成中间数据，因此数据的正确性对另一部分代码存在依赖，因而不能完全隔离两部分代码的正确性。从结果上看，在封装的过程中本文只保留了原有的代码隔离模块，并没有再对耦合模式分量实现中的已有代码进行拆分解耦。

src 目录存放了 cam 主要部分的全部源码。这部分源码的内部依赖较为复杂且难以拆分，因此本文选择将其作为黑盒进行处理。这里 cam 的对外接口主要是 cpl\_esmf 、 cpl\_mct 、 cpl\_share 三个目录，其中由于本文采用了 MCT 作为基本数据结构，因此主要接口为 cpl\_mct 目录下的 atm\_comp\_mct.F90 文件。 cpl\_share 目录提供了 MCT 数据结构的域定义和编号缓存，以减小多进程高频率的数据结构访问下带来的字符串操作对应延迟，最大化运行效率。这两个目录是本文封装过程中主要需要处理的部分。另外，代码各个涉及到错误处理的部分都要求与顶层耦合调试工具进行对接，因此还涉及数个需要调整的代码段。在针对 cam 模块进行的错误定位时，通常可以通过在内部控制模块 control 设置断点来进行大致定位并进一步调试。

test 目录提供了一套以 cam 为中心进行单元测试的模块，其测试范围包括 cam 独立运行和各种包含 cam 的耦合试验测试。由于本文对接口进行了适配修改，因此将 cam 作为整体的测试（包括对 cam 的封装级测试和对于带 cam 的外部耦合试验实例整体测试）由于接口发生变化而需要修改或直接放弃而无法运行，但针对 cam 各个内部模块的小规模测试依然成立，可以防止进行嵌入式修改后造成的数值不匹配或计算逻辑错误。

tools 目录提供了一些辅助调试的工具，主要用于不同格式的输入文件和数据文件之间的互相转换。顶层耦合中的部分代码和工具参考了这部分代码并进行了对各个模式分量的适配使得他们可以用于全部的模式分量实现中的格式转换。

总体上来看， cam 的代码结构是所有模式分量实现中较为复杂的一个。出于适配效率考虑本文并没有完整地分析其中的具体结构细节或是实现细节，而是尽可能将其作为一个可编译运行的整体来进行封装和适配来尽可能在保证其正确性和完整性的情况下减少适配工作量。值得一提的是，由于 cam 部分结构并不具有普适性且复杂度偏高，本文并没有采用该结构作为适配后的结构，而是参考了之后更为简洁和标准化的模式分量结构。在 cam 的适配过程中向目标结构进行了一定的修改的同时保留了 cam 部分框架特点以尽可能为 cam 模式分量实现的更新版适配做准备。

\subsection{pop2}

pop2 \cite{POP2doc} \cite{POP2faq}是海洋模式分量 ocn 的一个实现。该模式分量实现并不包含于本文要复现的 F2000 实验中，但其结构为本文进行其他模式分量封装提供了很大帮助，因此这里着重介绍一下 pop2 模式分量实现的结构。

与 cam 类似，pop2 提供了 bld 目录作为基于 csh 和 perl 脚本语言的共通编译框架，其内部结构与 cam 类似但更精简，且与本文的适配关系不大，在此不再赘述。但 pop2 模式分量实现在编写时还提供了另一套独立的自编译框架，该框架位于 build 目录下，并可以在没有外部依赖的情况下独立完成对 pop2 源代码的编译。这种编译框架能够极大的方便适配过程中进行的隔离编译和隔离调试，因此本文以该目录为模板对所有涉及的模式分量进行了附加自编译模块。特别的，对于 cam 模式分量来说，其编译系统较为复杂，直接插入附加自编译模块导致了部分冲突和重复编译，因此本文只对 cam 模式分量进行了特殊适配，保留了其原有的编译系统的基础上，将删减过的自编译模块以脚本调用的形式附加，从而保证了编译效率和正确性。

build 目录下提供了大量配置文件以在各个预设实验平台下编译。由于本文的实验平台并非预设平台，因此要对这些配置文件进行修改。本文选择了与实验平台较为接近的 linux 配置并对其进行了针对实验平台的改动，包括修改 NetCDF 等依赖库的配置路径，将顶层耦合模块提供的预设配置插入编译选项，设置 mpi 等依赖库的配置开关等。特别需要注意的是，耦合模式分量实现本身没有 C/C++ 代码，但这里必须要对 C++ 编译器进行配置，原因是 fortran 编译器处理部分宏存在问题，需要用 C++ 编译器进行不编译只展开宏的处理，并将处理后的代码放置在 compile 目录下再用 fortran 编译器进行整体编译。另外，默认配置下 fortran 编译器不具有多进程功能，而整个耦合实验必须在 mpi 的多进程模式下进行运行。因此这里编译器需要改为 mpif90 并可以将与单线程 mpi 相关的 mpi-serial 部分全部移除以提高编译效率。另外，当进行嵌入式调试时，调试信息可以被插入 compile 目录下宏展开后的代码以达成自动更新。该自编译模块的主要编译流程如下：

\begin{itemize}
  \item [1)] 
通过外部宏 ARCH 设定编译平台，载入对应的配置文件
  \item [2)]
通过外部宏 SRCDIR 和 EXEDIR 设定源码路径(通常为上级目录)和编译目标路径(通常为 build 目录本身)
  \item [3)]
调用 preprocess.mk 模块进行预编译，将所有找到的源码进行宏展开并放置到 compile 目录下
  \item [4)]
调用 depends.mk 和 fdepends.awk 生成编译所需的依赖
  \item [5)]
调用 compile.mk 依据所生成的依赖自动编译 compile 目录下的所有源码
  \item [6)]
将编译好的源码进行后续处理、打包并与顶层耦合平台对接
\end{itemize}

在上述步骤中，前两步的宏设置可以通过相对路径进行自动适配，因而可以自然应用到各个模式分量实现中。第三步预编译步骤会在若干指定目录下将所有找到的 fortran 代码全部进行宏展开，因此需要针对各个模式分量实现的路径框架进行修改。特别的，对于部分提供多种适配代码的模式分量实现(例如 pop2 同时提供了单进程和多进程的外部库，且他们的接口名称和格式都完全相同)，只能选择正确的版本进行预编译，否则会产生重名、冲突、适配错误等情况。预编译中，所有预设的宏都会被展开，因此可以在 compile 文件查看宏展开后的代码来确定是否所有的配置都被正确应用。第四部依赖自动生成设定上只考虑内部依赖，因此对于涉及的外部库 (包括顶层耦合提供的库函数和外部依赖库函数) 都需要在 fdepends.awk 文件进行注册(该文件是 linux 原生的字符串操作脚本语言 awk ，推荐使用 \href{https://www.gnu.org/software/gawk/manual/gawk.html#Getting-Started}{gawk} 进行运行)。生成的依赖文件将被放在 compile 目录的 depends 子目录下，并与第三部生成的宏展开后的代码一同进入第五步编译。这一步作为主要编译步骤，其所需的全部信息都在配置文件和之前的步骤准备完毕，因此可以进行全自动编译。在编译完成后，本文将编译生成的 .o 文件进行打包成为静态库，并将接口相关的 .mod 头文件自动传输至顶层耦合平台以备其他模块(主要是耦合代码核心模块 cpl )编译时使用。总体来说，只需要对平台进行一次配置和一次外部依赖配置，对各个模式分量实现进行代码框架目录设置，即可完成自动编译，因此该模块被本文作为耦合模式分量适配的主要模块来使用。

pop2 的主要代码实现部分由于并没有在 F2000 中使用，故略过不提。这里补充说明一些在 pop2 目录中可以被用来帮助其他模式分量实现进行封装或辅助调试的部分。 mpi 和 serial 目录分别对应多线程和单线程的 mpi 封装接口，在部分需要越过 MCT 层直接调用 mpi 进行操作的场合可以运用这些接口进行调用 (通常是用来调试)。 input\_templates 目录提供了各个分辨率的模板可以用于测试各种边界情况。 test 目录和 tools 目录提供了部分关于时间管理、历史记录和存储恢复的代码。实际上，各个模式分量实现的时间管理模块具有一定的相似性，因此本文提取了其中的共同部分，并加入了一些封装和额外功能作为顶层耦合模式的主时钟。这些代码都为顶层耦合实现的设计提供了参考。

\subsection{docn}

docn 是 ocn 模式分量的纯数据实现，也是 F2000 中唯一一个纯数据模式分量实现。顶层耦合模块的第一版耦合测试就是通过 cam 模块和该模块两个模式分量实现进行耦合完成的。其代码结构在所有的模式分量实现中最为简单，在封装中本文直接将其压缩为单个文件以最大程度上降低该模块可能产生的错误，从而把耦合模式分量调试集中到顶层耦合模块与 cam 模块之间的接口和数据交互中。

虽然核心代码只有一个文件，但作为一个完整的模式分量实现， docn 依然包含一套完整的模式分量实现结构：编译目录 bld ， 对两种耦合模式分量实现的接口 cpl\_mct 和 cpl\_esmf ，以及进行独立调试和输入输出的测试工具 tools 目录。值得一提的是， docn 的运行时配置文件 namelist 被拆分为 docn\_in 和 docn\_ocn\_in 两个文件，将专属于该模式分量实现的配置独立出来，以和其他 ocn 模式分量实现的运行时配置保持格式一致。另外，这里接口代码 cpl\_mct 的部分数据适配被移动到了核心代码 docn\_comp\_mod.F90 下，因此在适配过程中会与其他模式分量产生些许不同，本文会在下一章适配过程中详细描述这一部分。

总的来说，选择 docn 作为耦合实验实例的一部分不仅提供了更加简单和模块化的调试顶层耦合模块的流程，还为之后其他实验的纯数据模式分量适配提供了参照。

\subsection{clm}

clm \cite{CLMdoc} \cite{CLMtech} 是 lnd 模式分量的一个实现。该模式分量的特点在于有 clm4\_0 和 clm4\_5 两个等位模块，这两部分分别适用于不同的耦合实验实例，因此需要在配置时进行分别配置。每个等位模块内部将物理、化学和主过程进行了分离。这里的 bld 目录在适配入 pop2 的 build 自编译模块后其编译功能可以被舍弃，从而只需保留生成运行时配置文件的代码。

在实际适配中， lnd 模式分量遇到的主要问题是网格化后的边界处不满一格进行的处理需要顶层耦合模块的 fraction 框架与模式分量进行适配(实际上 ocn 模式分量也有类似问题，但 docn 模式分量没有输入需求因此不需考虑这一点)。为此，在 cpl\_mct 中的 lnd\_domain\_mct 函数中需要直接对 fraction 代码进行修改，使其能够从顶层耦合模型的配置中读取原本从文件中输入的网格大小和网格比例数据。

\subsection{cice}

cice \cite{CICEdoc} \cite{CICEgithub} 是 ice 模式分量的一个实现。该模式分量比上述模式分量的实现较为简单且有较为详细的文档。与 clm 类似的，这里只保留 bld 目录下进行运行时配置文件 namelist 生成的部分代码，编译部分同样交给自编译模块 build 。代码目录 src 提供了 mpi 的单进程和多进程接口， driver 目录下的 cice4 提供了一套能够独立运行和调试 cice 自身的驱动接口，其中 init ， run ， final 分别对应于 driver 接口中的三个接口，而 history 和 restart 分别对应顶层耦合模式的主时钟模块的两个功能历史记录和存储恢复。这部分代码作为独立调试使用，在最终模式分量编译和封装时不加入编译的源码目录列表。

在 cice 模块的 cpl\_share 目录下存放了与 cice4 同名同接口不同实现的模块。这些模块移除了调试并加入了 NetCDF ， ParallelIO 等多进程/线程加速代码以提高运行效率。在实际开发中，可以在 cice4 接口进行调试通过后，将其同步到 cpl\_share 接口中以确保多线程代码的正确性，并将加速代码代替 cice4 进行完整的库编译以达成隔离调试和运行提速。如果最终编译出现问题，则需要检查替换的多进程部分是否会出现数据不匹配或 race condition 等问题。

总体来说， cice 作为一个结构较为简单的模式分量实现，其自带详细的文档和独立调试模块，使得其独立适配难度较低。事实上，cice 和 docn 两模块构成的简单耦合实验实例相较 cam 和 docn 的耦合实验实例从代码层面上更加适合对顶层耦合模式进行调试，但 ice 和 ocn 模式分量对 atm 模式的输出存在较多依赖，因此需要追加 datm 模块才能较好地保证模式分量的数值正确性和稳定性。考虑到 cam 的重要性，最终本文放弃了 cice 选择了 cam 和 docn 的耦合实验实例作为第一版顶层耦合模式测试。

\subsection{rtm}

rtm \cite{RTMdoc}是 rof 模式分量的一个实现。该模式分量用于解决河流的流量，因此网格分布较为复杂、与各个其他模式分量都有交界，因而需要适配各种不同类型的网格分辨率转换。另外，由于河流自身边界影响较大，该模式分量实现自身需要较高的网格分辨率以确保数值合理性和稳定性，因而即使实际面积较小依然带来了很大的计算量。

rtm 的主要代码位于 src 目录下的 riverroute 目录，核心运算存放在 RtmMod.F90 中，其余文件分别提供了变量定义、时间控制、历史纪录、存储恢复、多进程封装、独立输入输出等模块。为了与其他 rof 模式分量保持一致，这里保留了 RunoffMod.F90 文件作为统一的接口进行适配，并由 cpl\_mct 目录下的封装部分进行调用。需要注意的是，冰雪融水径流量 rofice 和液态水径流量 rofliq 作为两个不同接口分别进行适配，因此在 ice 模式分量不存在于耦合实验实例中时需要对 rofice 数据进行预置处理以确保其物理含义正确。

\subsection{小结}

在确认 F2000 实验所需的各个模式分量实现的结构后，本文得出的大致结论是： clm 、 cice 、 rtm 三个模式分量的外部接口有较高的相似性， docn 模式分量作为数据模式分量处理工作量较小， cam 模式分量具有最高的结构复杂性，同时也对顶层耦合框架的编写存在较大帮助。另外， pop2 虽然不属于 F2000 实验所需的模式分量实现，但其通用的自编译插件可以极大的减轻对 CESM 模块的依赖，因此本文决定将该插件单独提取后分别对各个模式分量进行封装。

\section{接口适配}

在对各个模式分量实现进行适配的过程中，主要工作量集中在对 cpl\_mct 接口代码的修改和重构。特别的，为了完全移除对 CESM 框架的依赖，在适配过程中需要不断对顶层耦合模式分量追加所需的功能，因此对 cpl\_mct 接口进行全面分析成为必要。模式分量实现的接口通常由 init\_mct ， run\_mct ， final\_mct 组成，其中 final\_mct 的功能基本已由顶层耦合完全替代，因此本文将着重分析 init 和 run 两个模块。

\subsection{init}

init 模块是在顶层耦合模式启动时调用的模块，其目的为初始化必要的数据结构或从存储恢复文件中读取最新记录的数据结构，并将运行状态恢复至记录的时间点。其接口为顶层耦合模式分量中该模式分量可访问的隔离区域 compInfo ， 顶层耦合内部库的时钟模块 EClock， 已适配和转换分辨率的所有依赖输入数据结构 x2ice(atm/ocn/lnd/rof) ， 尚未适配且依然使用本模型格式和分辨率的输出数据结构 ice(atm/ocn/lnd/rof)2x ，以及错误代码 ierr。 init 模块通常需要引用该模式分量实现自身的历史记录模块和存储恢复模块，用于对该模式分量实现自身涉及的各个内部数据结构则交由顶层耦合模式在数据交换的同时进行历史记录或存储恢复。部分模块拥有自定义的日志模块，也会被引用到 init 模块下进行日志输出或与顶层耦合模块的日志对接。

初始化时出于效率考虑必须最先初始化与 MCT 数据结构相关的各个数据结构编号。这一步可以提前确认所有数据结构对接的正确性并对之后所有关于数据结构的操作进行提速。其调用 cpl\_share 目录下的 cpl\_indices\_set() 函数进行初始化操作，从而将各个数据结构的短字符串名称映射为数据结构内部的索引并缓存在各个进程中。为了确保可读性，这些缓存以人类可读的变量名命名(通常与预设短字符串名称保持一致)。与此同时， cpl\_share 目录也同时提供了部分可能不存在或未被提供的数据结构的预处理、初始化和边界处理功能。特别的，由于 fortran 语言及其大部分依赖库从 1 开始编号，因此 CESM 的源代码采用 0 来指定未满足的依赖。

初始化数据结构编号后从输入的 compInfo 中提取来自顶层耦合模块隔离区域可访问的数据结构。这些数据包括 mpi 通信接口 comm ，用于各种基于 mpi 或间接依赖于 mpi 的封装通信接口参数；模式分量编号 ID ，用于各种与该模式分量实现相关的文件名生成和通信接口生成；模式分量实现自身预设数据结构 domain ，存储了来自顶层耦合模块对该模式分量实现设定的配置（分辨率、接口设置等）；MCT 使用的多进程分配表 comp\_gsmap ，用于各个进程独立进行通信和运算时的分配。这些提取出的数据结构与 CESM 源码所使用的数据结构具有相同的格式，因此可以直接被模式分量实现自身的代码所使用而不需要进一步的适配。

此后是对于时钟的对接。顶层耦合模式提供了全局的驱动时钟接口，这里将其与各个模式分量实现自身的时钟接口进行适配和更新。同时，模式分量将自身的计时器和日志模块进行初始化，准备进入数据处理相关模块。需要注意的是模拟数据的时钟和运行时间记录的时钟需要分别进行初始化，前者可以看作输入数据，而后者作为运行状态的控制接口。在时钟准备完成后还需要将通信模块进行初始化以准备进行数据读写和数据通信，利用之前提取的 mpi 数据接口将高层封装通信模块进行设置的同时，将待通信所有数据结构的网格建立起来并对需要的部分进行初始化。至此，所有预处理完成，准备进行数据传输。

数据传输分为两种情况：从顶层耦合模块设定的时间开始读取输入，或从上次运行保存的最新位置恢复数据。前者需要从顶层耦合模块获取输入文件相关信息并读入对应数据，后者则通过自身的存储恢复模块直接将数据结构恢复为保存时的状态。为了防止数据不匹配等问题，通过顶层耦合模块进行的数据读取由顶层耦合内部库自身检查对应状态，而通过自身存储恢复模块进行的数据恢复则需要与顶层耦合模块的时间数据进行匹配从而确认正确性。在部分模式分量实现的数据文件出现损坏或不匹配的情况下，需要对顶层耦合模块作出反馈，使得顶层耦合模块的时钟回调至所有模式分量实现均保有正确数据存储的时间点重新运行。这个时间点并不一定需要为一个完整的运行周期，只需确保各个模式分量同步即可。

在文件读取过程中，需要考虑到模式分量实现自身或顶层耦合模式进行更新后的向下兼容等情况。全局输入文件中存在额外的数据结构不被使用是被允许的，而模式分量自身的存储恢复数据若存在额外数据结构，说明该存储恢复数据可能由一个更新版本的模式分量实现进行创建，在此情况下应当给出警告。另外，如果部分需要的可选参数并未出现在模式分量存档数据中，这说明存储恢复数据在上一阶段的运行中可能没有使用该部分数据或这个存档数据由更老的版本创建。在此情况下需要追加数据结构的初始化以确保各个数据结构之间的匹配。在多线程数据结构修改后需要对 MCT 相关的全局分配模块进行更新以防止 race-condition 等问题出现。另外，部分模式分量会在这个位置插入一些对于数据数值的检查以防止输入不满足模式分量实现的预设约束条件。

读取数据后根据自身进程配置和耦合模式分量进程配置进行基于 MCT 的 GSMap (global segmentation map，全局划分表) 数据结构进行多进程数据分配。同时将各个数据结构和顶层耦合模式提供的数据进行各个进程的广播。在耦合模式分量进行更新的过程中，可能会对分辨率进行修正和重新插值导致前后单元顺序出现变化，全局划分表可能需要进行追加和重新分配等操作。这里对可能出现的各种情况进行了分类讨论以确保全局划分表的正确性，并插入了错误处理代码以保证后续代码可以在多进程的环境下进行正确的代码分配。这部分运行通过后，至少可以保证后续的多进程代码在代码层面上的运行正确性，从而有可能进行多进程环境下对数据正确性的检测和调试。另外，这里同时用多线程模块对部分中间变量进行初始化，可以提前检测到可能存在的多线程运行层面上的错误，防止在计算过程中出现意料之外的数据不稳定等问题。

在多线程配置完毕后即可开始模式分量自身的初始化代码。这部分代码主要基于全局划分表 GSMap 和顶层耦合模式提供的隔离域数据。特别的，如果耦合器与模式分量实现的对接线程分配与模式分量实现自身的线程分配存在差异时，需要将 MCT 数据结构进行再适配并同步分辨率。模式分量实现自身的初始化部分与 CESM 保持一致，且输入格式全部适配完成，因此没有改动，直接进行封装和调用即可。此步骤完成后初始化运算完成，可以插入一定的调试日志等后续处理。全部完成后将运行标记置 1 以记录该模式分量的初始化阶段完成，这一步可以协助耦合器处理存在依赖关系的初始化。至此，初始化 init 过程全部完成。

\subsection{run}

run 过程是各个模式分量实现的核心过程。与 init 过程不同， run 过程会在每个运行周期被调用，因此需要自动检查时钟确认运行触发。其接口与 init 类似，同样包含隔离区域、时钟、适配后的输入、适配前的输出和错误代码五部分。这部分代码同样依赖历史纪录和存储恢复等模块进行写操作以预备不可预知的中断或外部影响导致的重新运行。日志、时钟和输入数据的对接与 init 模块相似，但此处无需对全局分配表 GSMap 进行操作，直接利用 init 的存储进行多线程数据处理即可。需要注意的是，在处理来自其他模式分量的数据传输(如流量数据 flux )时，需要确保所有进程都位于指定代码段，即所有预备数据都已准备就绪，以防止出现数据不一致等错误。实际上，所有对之前数据的完整性有依赖的步骤都需要进行线程间同步，这也对全局分配表的合理性提出了要求：若运行时间不平衡，同步造成的木桶效应可能导致多线程系统的效率出现较大幅度的下降。在主要计算部分运行完毕后，分别调用顶层耦合时钟确认是否需要进行历史记录和运行状态存储。最后，输出数据需要传输给顶层耦合模式的对接进程。这里输出数据虽然无需进行分辨率变更，但若顶层耦合模式的线程划分与模式分量实现不一致，则需要进行由模式分量实现自身发起的进程间数据传输，以确保输出数据对顶层耦合模块可读。在运行到终止状态时，进行一套额外的处理以确保最终态数据和状态被存储。考虑到单独重新解析顶层耦合模块的传输数据较为复杂耗时，这部分代码并没有放入 final 模块，而是直接在 run 模块以一个只会被触发一次的时钟进行调用。于此相对， init 模块并不能这么做，因为在读取时钟之前多进程所需的环境尚未配置完毕。综合来看本文舍弃了 final 模块，而保留了配置环境的 init 模块和最大化运行效率的 run 模块。各个模式分量的 run 模块结构大致相同，但具体实现中接入了一些需要根据顶层耦合提供的选项进行调整或内部参数调试的部分，下面本文将对其分别进行展开。

cice 模式分量实现将 prescribed 模块的存在性放在 run 模块内处理，并将 diagnostics 诊断模块单独运行以测试其对整个运行时间的影响。 radiation 辐射模块作为插件同样单独进行了测速，另外 run 模块还负责根据输入数据情况决定是否运行第二步热力学函数调用。动态调整和辐射模块都被封装为单步骤运行接口，并直接在 run 模块内根据运行开关进行调用。这种结构可以直接在接口文件中对其运行方式进行修改以达到在不更改和重编译其他代码的情况下对不同算法进行测试，从而达到降低编译复杂度，减小对照试验工作量的结果。由于 cice 内部只提供了 NetCDF 格式的输出，但顶层耦合模块需要支持文本格式的输出，因此这部分代码直接作为插件放在了 run 模块中。

clm 模式分量实现将主循环直接放在了 run 模块中，在单个顶层耦合模式分量对 lnd 模式分量的时间跳变步骤过程中进行模式分量内部的迭代。该迭代基于反射系数进行计算每一步运行的间隔，因此相关的物理量被直接在 run 模块进行读取和判定运算。模式分量实现内部的每一步跳变被封装为单步驱动 clm\_drv 并传入计算好的反射相关数据作为接口。在每一步运行完毕后，立刻将所得数据转换为与顶层耦合模式适配的格式。在整个主循环运行完毕后，最终的结果将进行一套标准化，之后作为 run 模块的输出传输给顶层耦合模式分量。

rtm 模式分量由于不涉及内部迭代步骤问题，直接将整个内部函数封装为 Rtmrun 函数，其接口直接对接 init 函数预先开辟的一部分用于数据格式转换的内存 totrunin ，存储恢复时钟 rstwr ， 终止时钟 nlend ， 数据时间戳 rdate 。这里 run 模块只封装了数据格式转换代码和部分日志代码。

docn 模式分量作为纯数据模式分量，其代码逻辑较为简单，因此封装代码意义不大，本文直接将主过程放入 run 模块内，具体来说直接通过顶层耦合模式预设的数据模式进行数据初始化和数据读取，并将读入后的原生数据处理和正确性检查直接在 run 模块函数体内实现。由于是数据模式分量，其历史记录模块同时提供了数据误差分析功能，这部分代码同样放在了 run 模块内，代替原本的历史记录写入模块。由于外部数据分析不再必要，这里的存储恢复模块直接采用文本文件写入。

总体来说，各个 run 模块结构存在一定差异，主要将模式分量实现自身可能的不同运行方式控制代码放置在接口函数中，而将不变的部分以内部库函数的方式存放。这样当两部分分开编译时，对运行方式的修改可以以最低的编译代价完成更新。相对的，保留这部分代码会使接口函数的可读性一定程度上下降。幸运的是，本文进行代码层面的适配时，只需将与顶层耦合模块相关的部分进行替换和对接，对模式分量自身的运行逻辑可以保持原状态，从而尽可能减少适配可能带来的代码逻辑修改所带来的数据不一致等问题。

\section{小结}

至此，本文完成了全部对模式分量实现接口的适配工作。接下来本文将通过顶层耦合驱动对所有的模式分量进行调用，从而进行实验实例的正确运行。
