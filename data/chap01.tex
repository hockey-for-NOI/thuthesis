\chapter{相关工作}
\label{cha:related}

在这一章里，我们将分别介绍与本工作相关的下列内容：
\begin{itemize}
  \item [1)] 
  国外耦合技术相关的各个主流代码框架 CCSM 、 NUOPC 、 MCT 、 ESMF等。
  \item [2)]
  待复现的 CESM 实验代码的主要框架、代码结构、运行方式。
  \item [3)]
  已有的基于代码生成的耦合代码生成框架的主要模块、集成功能、接口实现、调试环境等信息
\end{itemize}

\section{国外耦合技术相关}

CCSM \cite{CCSM} 社区气候系统模型是本文将要复现的实验所在原平台 CESM 的前身，用于模拟地球气候系统的耦合气候模型。其特点是可以从物理和代码层面支持多种不同的配置，包括不同分辨率和不同模型连接方式。每个模式分量都配置了特定物理模型和输入选项参数，以简化用户操作。CCSM可以在各种预设硬件平台上运行，并且在模式分量的进程分配和布局方面具有相对灵活的设计。CCSM 还支持内部库拼接和对接口进行二次开发适配。

NUOPC \cite{NUOPC} 是一套用于在模式分量间进行接口适配的库函数插件，它既可以被视为一个库函数进行调用，也可以通过将其封装为一个只进行数据传输和适配、不进行数值计算的伪模型进行模式分量间的通信。前者要求用户编写的模式分量将 NUOPC 作为一个外部库进行依赖和调用，而后者要求用户将 NUOPC 和 自行编写的模式分量等位地通过耦合模块进行编译。因此，该模块既可以在不依赖耦合器的情况下进行简单的模式分量通信，也可以在已有耦合器的情况下通过加入伪模式减少其他模式分量的数据传输模块编写复杂度。

MCT \cite{OPENMCT1} \cite{OPENMCT2} 是一套基于 openmpi 的多进程数据结构通信封装接口，用于创建耦合模型并提供基本存储和通信。由于大部分耦合实验实例都需要在多进程环境下运行，因此该库被各个耦合实验库和平台广泛使用。MCT 提供了在不同线程分配情况和不同分辨率情况下的多线程对多线程数据并行传输和并行插值功能，并对其进行了针对性的运行效率优化，使得耦合模型实例的通信效率得到提升。本文最终复现的实验依然以 MCT 作为基础数据结构进行通信。

ESMF \cite{ESMF} 是一套地球气候系统模型社区工具库，其目的是协助开发高性能、多模式分量的地球科学建模应用。ESMF 提供了一套适配较为简单的接口给各个不同类型和不同结构的模式分量和耦合框架使用，通常只需对输入输出进行适配即可自动完成对接。ESMF 本身并不包含于物理或气候科学相关的代码，这使得它可能应用于更广泛的场景。另外，ESMF 还提供了开发者模式，可以根据实际需要对 ESMF 部分代码进行修改和扩展以适应更加复杂的情况。本文中的耦合代码生成框架对 ESMF 的设计思路和部分代码进行了参考，从而保留了不低于 ESMF 的适配灵活度。

\section{CESM}

CESM\texttrademark\footnote{http://www.cesm.ucar.edu/}，全称COMMUNITY EARTH SYSTEM MODEL，是由NCAR于1983年创建，作为供更广泛的气候研究界使用的免费全球大气模型。在过去的20年里，NCAR气候与全球动力学（CGD）部门为大学和NCAR科学家提供了一个全面的三维全球大气模型，用于分析和理解全球气候。由于其广泛使用，该模型被指定为社区工具，并被命名为社区气候模型（CCM）。经过20年的研究与发展，CCM的公式已经稳步改进，且运行该模型所需的计算机变得相对便宜且广泛可用，因而该模型在大学界和一些国家实验室中逐渐被广泛使用。

原始CCM模型的局限性在于它不包括全球海洋和海冰模型。因此，在1994年，NCAR科学家提交了一项计划，以国家科学基金会（NSF）开发和使用气候系统模型（CSM），其中包括大气、陆面、海洋和海冰的模型。这些模式分量能够对分量间的通量不进行任何的情况下进行耦合。该计划最初侧重于气候系统的物理方面，然后在随后的版本中追加了生物地球化学插件和高层大气模式分量。该项目的第一阶段是NCAR工作人员开发的模型，之后，模型和相关数据集将提供给科学界。此外，该项目还计划建立一个新的模型和代码社区，让感兴趣的科学界有机会参与CSM的各个方面。这也是我们能够基于该模型进行后续开发和封装的重要条件之一。

\subsection{主要框架}

CESM代码主要分为两部分：模式分量和实例生成脚本包。

模式分量主要分为大气模式分量atm\footnote {atm: atmosphere}，海洋模式分量ocn\footnote {ocn: ocean}，陆地模式lnd\footnote {lnd: land}，海冰模式ice\footnote {ice: sea-ice}，冰川模式glc\footnote {glc: land-ice}，海浪模式wav\footnote {wav: ocean-wave}，海河径流模式rof\footnote {rof: river-runoff}，以及一个专门用于数据交换的模式分量drv\footnote {drv: driver, 也作coupler, cpl}。

单个模式分量内部包含多种实现方式。不同实现方式通常含有不同意义，例如采用不同假设、运算核心公式不同、计算精度差异、网格划分和网格密度不同、物理意义不同等等。通常情况下每种模式分量选择且仅选择其中一种实现进行耦合运行。在特定的条件下（如在线比对同一模式分量的多种不同实现方式）可以在单个模式分量中应用多种实现方式同时进行耦合运算，但此种情况下数据处理会变得较通常时更为复杂。另外，如果某些模式分量对于整个实验来说影响很小或是并不关心，可以不采用实现或采用空实现。一般来说，一个以气候模拟为目的的耦合模型通常只采用每种模式的单一实现。

最常见的模式是纯数据模式分量，这种模式分量取 data 首字母 d 开头命名，作用是读取
测量数据用于与其他公式型模式分量进行数据交换，并接收其他模式分量传入的数据与真实数据进行对比做出数据统计
和误差分析。通常来说当单个模式分量要进行适配测试时，会将所有与之直接相连的模式分量设置为纯数据模式分量，
从而确保了待测试分量从其他分量获取的输入值较为准确，可以帮助进行针对待测试分量的耦合运行和数据分析。
而对于与待测分量不直接相连的分量，通常采用空实现以尽可能减少运行时间。另外，在某些综合耦合实验中，若某些
模式分量的实现与其他主要模式分量有较大差异，如实现未完成
(本文复现的 F2000 实验就是在海洋模式 pop2 未完成的情况下，用 docn 模式代替进行的实验)
，单个模式测试不满足要求，误差量级不符，联合测试不稳定或无法收敛等情况，可以采用纯数据模式分量代替其中不满足条件的分量进行耦合验证
(需要注意的是，此种情况下耦合模型误差较一个真实模式分量实现偏小，数据分析时应当考虑到这一点)
。

模式分量的主要实现方式取 community 首字母 c 命名，这种模型在CESM社区中广泛使用，经过各种工作人员和科学家的共同开发，以及大量实验验证和改进，通常被认为是该模式分量的 baseline 。实际上，当一个新的模式分量进行耦合测试时，其正确性由于纯数据模式分量的耦合测试来保证，而其实际精度通常根据由社区模型进行耦合而成的模型进行测算。这可以在一定程度上反映该模式分量实现对来自外部误差的敏感程度。另外，该社区模型也会不断采纳来自其他模型的公式进行修正，因而保证了其的即时性和准确度。目前大部分成型的实验都包含相当数量的社区模型作为其模式分量的实现。

另外还有残余模型和死亡模型。前者只有接口而没有具体内容，在耦合模式完全不需要也不读取某个模式分量的数据时使用，最大化运行效率。死亡模型则采用随机的公式进行计算，并将得出的随机结果传输给其他模型。这种模型无法得出有意义的数据和统计结论，通常只用于测试可行性和数据溢出错误处理，或配合其他模型测试运行速度。在实际的耦合实验中，残余模型经常被接入被忽略的部分，而死亡模型不会出现在实际耦合实验中。

驱动模式分量，也作耦合模式分量，是专门用于各个模式分量的数据交换的一个特殊的模式分量。在CESM代码中这个模块是作为一个模式分量来看待的
\footnote {而在我们的代码中，这个模块作为顶层耦合器被独立提出并进行改进以增加适用性}
。
在任何实验中，驱动模式分量必须存在，且每个模式分量都只和驱动模式分量进行通信。因而所有的通信方式都被硬编码为“向驱动模式分量发送数据”和“从驱动模式分量获取数据”。实际上，驱动模式分量也有不同的实现方式
(常见的包括 cpl\_mct ， cpl\_esmf 等)
，而对于每种驱动方式，由于数据传输被硬编码在每个模式分量中，因此每个模式分量的每一个实现都必须对驱动模式分量的每一个实现进行分别硬编码(这应该是CESM最严重的缺点之一，也是我们主要要解决的问题)。

实例生成脚本包是一套用于在不同平台上自动或半自动配置各种已完成实验来进行复现的一套工具。一个新的实验完成后也会被添加到这个脚本包中，同时该模型的简要构成和各个模式分量的实现会被放到CESM官网的
支持分量集合
(http://www.cesm.ucar.edu/models/cesm1.2/cesm/doc/modelnl/compsets.html)
中。
复现一个已知实验时，如果在CESM预设设备群中\footnote{大部分预设设备配置了固定的绝对路径以找到对应的输入文件，表格文件等配置，在自用设备中需要自己单独配置}，在这个表格内找到待复现的实验的短代码，并将其与设备名称一同输入到 cesm\_setup 脚本中，即可完成全自动配置。

实际复现中，由于我们运行的实验平台并不属于预设平台，需要自行修改配置文件以运行和复现。此种情况下，需要将配置脚本进行拆分，自行下载输入数据和安装依赖包，并把对应的输入文件和表格文件放到其硬编码的路径下以实现半自动配置(实际上，在我们重构的耦合平台中，这一步骤被改进为自适应地构建，可以根据数据包路径结构自行调整)。具体来说， cesm\_setup 脚本读取预设配置文件，将所有依赖库分发到各个模式分量的实现中并分别编译，并将输入文件和表格文件的硬编码路径写入每个模式分量实现目录下的 namelist 文件作为运行时配置。我们可以修改 cesm\_setup 脚本的硬编码路径，也可以选择分别手工编译每个模式分量实现后修改生成的 namelist 文件以达到同样的效果。

特别地，部分配置在 namelist 内的文件存在互相依赖，例如两个不同模式分量实现采用了不同的网格密度，因而需要在边界进行插值时，就需要两边的差值矩阵保持一致。CESM的实例生成脚本中，通过 xml 文件记录每个模式分量实现的分辨率，从而保证生成的 namelist 文件中的差值矩阵对应。因而在实际复现中，如果直接采用分别构建时使用的 namelist ，容易产生权重不匹配的错误。在耦合器的设计中，我们将这一部分完全包装在耦合器内部，从而确保了其能够正确匹配并交换数据。

\subsection{代码结构}

CESM 的主目录下有3个目录，分别是 models ，包含所有的模式分量； scripts ，包含一套实例生成脚本和相关的预设配置文件； tools ，包含一些用于测试和数据分析的代码库。

模式分量目录下包含11个目录，分别是8个主要模式分量类型 atm , ocn , lnd , ice , wav , glc , rof , 以及驱动模式分量 drv ，模式分量实现通用库 csm\_share ， 死亡模式分量通用库 dead\_share ，以及对外部库或部分成模块的功能进行了部分封装的 utils 目录。

除去驱动模式分量 drv 外，主要模式分量目录下存放了该种模式分量的全部实现。每种模式分量实现由于编写者不同而结构略有差异，但主要部分由编译和配置目录 bld ，文档目录 doc ， 代码目录 src ， 测试目录 test ， 封装目录 tools 等构成。在代码中的 drivers 目录下(部分实现直接放置在根目录下)均包含 cpl\_mct 目录和 cpl\_esmf 目录用来适配两种不同的驱动模式分量接口，以及 cpl\_share 目录用于定义接口中的通信域。实际上，在整个模式分量实现中，通常只有  drivers 目录下的代码会与外部进行通信。因而在重构时我们尽可能保留了其他部分的完整性。

驱动模式分量 drv 的目录结构与单个主要模式分量实现类似，其主目录下直接存放了两种实现 shr 和 shr\_esmf ，分别对应每种模式分量实现的接口 cpl\_mct 和 cpl\_esmf。在驱动模式分量的 drivers 目录下不再放置上述两种接口，而是存放了两种实现所共用的代码部分。由于这部分代码具有较高的通用性，我们在重构时也保留了其中的主要框架，只对部分涉及适配能力的代码进行了修改。

实例生成脚本 scripts 目录下包括记录了主要预设实验的组成和模式分量实现信息的 ccsm\_utils 目录，doc 文档目录， validation\_testing 测试用例目录，以及三个主脚本 create\_newcase ， create\_clone 和 create\_test， 分别用于创建、复制和测试一个实验实例。在一个创建了的实例中，运行脚本 cesm\_setup 即可自动选择所用实验的各个模式分量实现，并依据所设置的机器型号适配依赖库进行编译，同时找到输入和网格文件位置，最终生成一套可以运行和测试的实验实例。

\subsection{运行方式}

在一个可以运行的实例中，必然有一个驱动模式分量被选择。该驱动模式分量负责初始化需要被各个模式分量实现调用的数据结构并可以从记录文档中恢复这些数据结构到之前的某个时间点的运行状态以达成继续运行的效果。此后驱动模式分量调用各个模式分量实现中与该驱动模式分量实现对应的接口以通知各个模式分量实现可以进行对应的初始化。在此阶段，各个模式分量可以并行地独立进行基于驱动模式分量中共享数据来对模式分量内部数据结构的初始化。在这个过程中驱动模式分量并不具备只读特性，因为各个模式分量可能会把关于自身实现的一些信息记录到公共模式分量的共享数据部分以供驱动模式分量或其他模式分量使用(实际上，这种设计很可能带来不同模式分量实现中的 race-condition 问题，且由于涉及的模式分量可能不止一个，而共享数据区上锁又会较为严重地影响效率，因而在我们的复现设计中进行了对驱动模式分量中各个模式分量可以访问的数据区的隔离以从根本上避免这种情况的发生)。在部分耦合实验中，某些模式分量需要二次初始化或在其他模式分量初始化后才能进行初始化的依赖关系(常见于可独立运行的 cam 大气模型)，这一部分代码被硬编码在驱动模式分量中(这里较为合理的做法是提供一个带依赖的可动态适配的初始化接口，但由于现有模型中对此功能需求极少，目前尚未进行正确性测试)。另外，每个模式分量实现也会从自己预设的路径中读取数据并恢复到上次保存的状态，因而这些数据需要确保同步(事实上全部存入同一个文件是可行的且可以避免不同步问题产生，但由于存在中途换模型的需求，我们保留了这种依模式分量存储记录的结构)。这些初始化流程全部运行完毕后，整个耦合实验的初始化完成。

主要运行流程由各个模式分量实现分别完成，不同模式分量有着不同的运行周期，这个值与客观物理事实相关(例如大气的数据变化周期远小于海洋，在 F2000 实验中它们的运行周期分别是 3600 秒 和 86400 秒)。每当一个模型运行完毕，它的数据就会被发送到驱动模式分量，并由驱动模式分量转发给所有与之直接连接的模式分量。这一步的实现考虑到部分模式分量运行周期较长，在这个运行周期中与之直接连接的模式分量可能会运行多次，因而数据会被传送多次引起浪费，因而采用懒操作减少数据传输：只有当模式分量将要开始进行新一轮迭代时，它才会从驱动模式分量获取其所需的所有与之相连的模式分量数据。另外，由于不同模式分量实现的分辨率和网格不尽相同，在数据传输的过程中需要进行插值操作，而这个操作即使在多进程的情况下复杂度依然相对较高(我们将会在之后的篇幅中详细讲述这一点)。懒操作也能减少插值次数从而降低运行复杂度。

在整个耦合实验运行过程中还有两个重要的模块：历史纪录模块和存储恢复模块。他们要做的事情较为相近，都是将整个模型当前的状态保存到存储介质上。不同点在于，历史记录模块只需输出该实验所关心的信息，该信息需要可以从外部进行读取和数据分析，但并不需要耦合试验代码自身可以读取，即历史记录文件对于耦合实验代码来说是一个只写( write-only )文件。与之相对，存储恢复模块的目的是可以在由于内部或外部原因导致的运行中断时，可以从上一次记录的时间点继续运行而不必从头开始计算的模块。因而该模块需要记录整个耦合实验运行所需要的全部信息，包括但不限于各个模式分量的最后一次输出数据，整个实验代码的运行状态，每个模式分量内部存储的数据结构等。该信息并不需要可以从外部进行读取或数据分析，但要求耦合代码本身可以读取并从中恢复运行状态，因而对于耦合实验代码来说是一个读写( read-write )文件。另外，还有一种较为特殊的情况：耦合实验运行到途中需要更换某模式分量的实现。这种情况下模型输出和模型输入的格式都可以设定为标准格式，但模型内部数据结构会存在变化而无法适配。解决这个问题同样要求我们将驱动模式分量的恢复记录与各个模式分量内部恢复记录分开存储，并根据模式分量实现来决定初始化内部数据结构或从较旧的版本向下兼容地读取必要的数据结构来完成数据恢复并继续运行。

最后，所有的历史记录模块输出构成了一个基于时间序列的耦合模型输出文件。这些文件通过外部工具提取后进行数据分析和可视化，即可将整个模型的预测结果以人类可读的形式显示出来。为了实现这一点， CESM 提供了一个外部工具 NCL (NCAR Command Language, http://www.ncl.ucar.edu/Applications/lsm.shtml)来进行对历史记录文件的可视化。

\section{耦合代码生成框架}

由于 CESM 的种种限制，编写我国自主研发的耦合平台成为一个重要的任务。已有的基于代码生成的耦合代码生成框架\cite{zhonganrun}参考了 CESM 的主要框架，在尽可能不改变或少改变 CESM 单个模式分量的实现细节基础上，通过对其中涉及数据交换、输入输出、运行控制等关键代码进行了针对性的重构，使得整个耦合平台摆脱了原 CESM 代码的绝大多数限制和可能遇到的问题，从而使得对不同模式分量的实现对接更加灵活和可靠，从而达到提高实验效率、加强实验稳定性、减少实验工作量等目的。

\subsection{主要模块}

耦合代码生成框架主要将原 CESM 中必定存在的驱动模式分量提高到顶层，并规定使用 cpl\_mct 模式以简化各个模式分量实现的接口。代码生成框架将原本分散于各个模式分量实现的运行状态、储存恢复等通用模块以内部库的方式存放在生成代码库中，并将整个驱动模式分量的代码完全重构。重构后的代码主要分为库函数部分 baseCpl 和 代码生成框架部分 src 。

库函数部分作为生成实例的主要构成部分，其拥有一套完整的自动编译体系。在源码中除去 CESM 固有的库函数 ccsm\_shr 目录外，将驱动模式分量分为了九大部分：

data\_def 目录存放原本在驱动模式分量内的共享数据结构。在这里我们对其进行了修改和封装，从而几乎完全避免了不同模式分量间可能存在的 race\_condition 等问题。为了动态适应不同模式分量和减少存储空间浪费，这一部分代码的域被设定为由代码生成模块进行生成。

depUtils 目录存放需要用到的外部库。实际操作时也可以将外部库安装到环境变量中，但若需要对外部库进行版本控制，这个位置的库可以根据需要进行设置并自动编译和加载，从而提供了更多的选择方式。

esm 目录存放和具体实验相关的域名称与标识对照表。这是一个将地理实验所需参数名称和代码运行尽可能隔离的设计。在程序运行中，模式分量实现中传递的数据只有序号标识；而在数据分析中，可视化后的结果将使用名称标识来提高可读性。需要注意的是，不同的调试场合可能分别需要名称标识或序号标识，因此调试工具需要配合这个模块来进行设计。

FluxSubroutine 目录存放与数据传输相关的代码。这部分代码主要执行不同模型间数据传输时需要进行的分辨率变更和多线程分配等操作。这一部分只涉及模型间的分辨率变换，输入输出全部为耦合器内的数据结构，因而可以与具体单个模式分量实现隔离。需要注意的是，各个模式分量之间的通信关系由于涉及到数据格式不适合作为输入，因而在代码生成模块中通过配置文件确定，并将对应的数据传输和分辨率变更编码相关代码生成到该目录下。

logUtils 目录存放输出日志相关的代码。调试模块的相当一部分是基于日志进行的调试，该模块可以较好地进行调试信息的控制、带有区分性质的自动前缀分配等操作，可以相当程度地提高调试效率和减轻调试工作量。

MCT 目录存放了 CESM 代码中关于多线程的关键模块，也是我们的耦合器代码的主要数据结构和数据传输依赖。由于耦合模型的运行速度需要，各个模式分量的实现必然使用多进程进行数据存储和并行运算。 MCT 库是基于 openmpi (https://www.open-mpi.org/) 的一套针对耦合模型设计的数据存储和数据传输结构，一套相关的数据按照全局分割表进行依进程的存储分配，并可以看作一个整体进行数据交换和不同模式分量实现中的再适配。耦合器内部的大多数数据结构和存储都是在 MCT 基础上进行搭建的。

models 目录存放了每种耦合模式分量的实现，与 CESM 不同的地方在于，每一种耦合模式分量实现被平铺在该目录下。由于耦合模式分量间的联通方式和数据交换可以通过代码生成模块进行任意构建，因此在设计上直接跨越耦合模式分量层对实现进行耦合，可以从结构上根本解决部分模式分量缺失或同一模式分量同时使用多个实现进行调度或对比的情况。后者可以直接将两个模式分量分别设定为相同的连接方式和数据交换即可。另外，考虑到调试器的隔离，该目录不在耦合器内部进行编译，而在生成实验实例后分别编译为静态库再进行链接。这样可以在实例中对某个特定模式分量进行调试以至直接进行二次开发。

MrgSubroutine 目录存放了将各个相邻模式分量传输来的已被调整为当前模式分量实现的格式和分辨率的数据进行整合的代码。这一部分的输入实际上是经过 FluxSubroutine 代码的格式转换、分辨率调整和适配后的数据，不需要考虑数据的格式问题，因而我们在这里将其与代码生成模块进行隔离来独立编写，提高编译效率和稳定性。

procManage 目录存放了对 MCT 模块和 openmpi 的封装代码，并进行进程管理的模块。所有需要使用多线程数据结构的代码都需要与该模块进行交互。为了确保稳定性，这一部分代码同样独立于代码生成模块并进行了一定程度的优化。

test 目录存放了部分测试代码。这部分代码被设定为独立于耦合代码编译和运行，且最终不会被加入到实例中，通常用于测试外部库的安装和路径设置等的初步正确性。

timeManage 目录存放了耦合模式分量的时间控制信息。所有的模式分量实现运行周期和耦合器自身的历史纪录、存储恢复等模块都需要根据时间控制部分进行调度。为了避免访问冲突，时间记录本身设定为对模式分量实现只读，通过自身设定周期进行时间序列模拟。在由顶层耦合模块分别调用各个模式分量，然后由各个模式分量根据自身的运行周期对时间控制模块进行注册，并在顶层耦合模块进行调用时在注册的时间到达的情况下触发对应模式分量的运行或顶层耦合器的历史纪录和存储恢复。

transManage 目录存放了多线程数据传输的相关代码，包括分辨率适配和多线程插值。多进程插值的实现与进程重分配隔离，因而我们可以在单一进程组进行插值的并行处理从而提高插值效率、添加异常插值检测模块并提供更加稳定的调试接口。

utils 目录存放了从 MCT 数据结构向历史记录文件和存储恢复文件进行依条目读写的封装库函数。这里我们进行读写的历史纪录文件和存储恢复文件均采用了通用的 NetCDF 文件格式，并使用 ParallelIO 外部库进行 NetCDF 文件的多进程读写。这一部分代码既被顶层耦合进行全局读写所使用，同时也可以为各个独立模式分量自身的存储恢复文件读写提供接口，因而我们将这部分代码独立存放为一个内部库。

utilsAux 目录存放了针对顶层耦合代码进行历史记录和存储恢复的较高层读写 API ，包括自动进行文件名设置、文件条目名与数据结构内条目名的原生对应关系设置等。为了减少存储开销、提高代码运行效率和数据结构利用率，这个目录与代码生成模块进行直接连接，只选取必要的部分进行读写，最小化输入输出开销。

上述模块组成了生成耦合实验实例的全部代码。然而，这些代码的编写很大程度上依赖于模型设置和模式分量实现间的数据通信和依赖关系。因此，相当一部分代码是通过代码生成模块辅助编写的。代码辅助模块是一套通过读取用户编写的 xml 配置文件进行全自动代码生成的工具，其输入文件位于根目录下 composing 目录中的 xml 文件，并将生成的代码直接写入 baseCpl 目录中的对应代码模块目录。代码生成模块本身采用 python 语言编写，位于根目录下的 src 目录，主要分为 instCreator 生成代码主程序和管理模块， instManager 实例管理脚本， ir 实例注册模块， parser 输入解析模块， template 代码生成模板， ErrorHandle 运行时错误处理模块。由于 python 语言的特性，每个文件都可以被视作一个单独的模块进行处理，因而数量偏多，我们直接在之后的接口实现章节中按照用户输入的 xml 文件被处理的流程进行更加系统和详细的介绍。

\subsection{集成功能}

代码生成模块基于开源外部库 Cheetah 进行实现。模板代码存放于 template 目录下，通过其他模块从用户输入中提取出必要的信息调用库代码将其编写入代码模板从而生成真实的代码。这里采用模板进行编写可以尽可能提取出较为固定但对用户输入存在依赖的公共代码部分，从而减轻用户编写耦合模式关系时的工作量，使用户能够专注在物理过程间的关系而降低对代码部分的工作量。

parser 模块分析用户输入的联接关系和不同模块之间需要进行连接的数据，将其通过 ir 模块注册入不同模块间交互的数据结构定义中。模块间的连接关系被代入 instCreator 耦合代码生成模块，进而将模板中数据传输时的格式适配、分辨率调整等代码进行生成。在这些代码全部生成完毕后，通过脚本全自动放置在 baseCpl 目录下的指定位置并进行对应的库函数预编译。因而，用户只需编写所需的 xml 配置文件，即可生成一个完整的可运行实例，在各个模式分量实现调试通过和适配成功的情况下即可直接进行运行，从而达到全自动运行的结果。

\subsection{接口实现}

用户与代码生成模块的对接、生成代码与耦合器固有库的对接、顶层耦合与各个模式分量间的接口实现是该耦合模式分量适配和运行中非常重要的一环。下面我们依次介绍这些接口的实现。

用户需要编写的是 composing 目录下的全部 xml 格式配置文件。这些配置文件描述了所有模式分量实现的信息、耦合实验架构和根据不同模式分量配置需要进行调整的参数等信息。

models.xml 文件描述了所有模式分量实现的顶层信息，包括模式分量名称、模式分量实现名称(注意到我们是越过模式分量层直接对模式分量实现进行操作，因此这里模式分量名称作为一个对 CESM 的兼容性接口是可以有多个实现的名称相同的)，源码目录，配置数据，存储数据结构，调用接口等关于单个模式分量实现的所有对外接口信息。需要进行带有读写的数据交换的数据结构以 fluxes 命名，而只由单个模式分量进行计算的数据结构以 states 命名(这些数据可能由于其他相连的模式分量需要以只读的方式进行读取，所以需要在该文件中进行描述)。与之相对的，模式分量内部信息等不与外部进行直接交互的信息则只需要在模式分量实现内部体现而不必写入该文件。另外，对于同一个数据结构有多个适配态和分辨率，我们用后缀区分，而只需要注册不带后缀的本名即可。该文件中的分辨率等配置在 CESM 代码中是以 namelist 文件进行配置的，在这里由于分辨率涉及全局设计和顶层耦合视角，我们将其调整为在全局耦合的 xml 配置文件中进行记录。涉及到的相关分辨率调整和适配部分我们通过其他的 xml 配置进行辅助后全自动生成，从而所有的接口也不需要注明分辨率和适配。在不同耦合实验中，模式分量实现可以互相通用，因此 models.xml 文件不必根据耦合实验实例进行改变，只需要在描述连接方式的其他配置文件中修改所需的耦合模式分量实现即可达成不同实例间的自动切换。为了防止此文件过长，具体模式分量实现内部的配置信息通过引用其他 xml 文件进行配置。

fakeModel.xml 文件提供了对一些特殊的通量数据结构进行数据传输和附加适配运算的配置方案。这里主要为了解决海气通量( Atmosphere-ocean Fluxes )在耦合时需要同时被两个模式分量实现处理的问题，从而将海气通量本身看作一个无需进行自身运算只需进行数据交互和适配运算的伪模式分量。其配置与 models.xml 内容较为相似，但为了给伪模型提供较多的配置空间，允许有复数代码接口并分别注册，在顶层耦合视角看作一个仅由内部库函数组成的模式分量，从而直接绕开了耦合模式分量实现在生成后需要重新配置的问题。

option.xml 记录了所有的固定库函数配置信息，这里主要是与时间记录相关的配置信息，包括起始日期，各个模式分量的运行周期，历史记录的写入周期，恢复记录的写入周期。这些数据原本也是存放在 CESM 的 namelist 文件中，考虑到设计时需要处理各个模块的运行周期并进行同步地调节，这里将其整合到时间记录库的参数配置文件中，选择通过代码生成模块进行传输而不是通过输入文件在运行时读取以防止不匹配的情况。

setup.xml 文件描述了在当前耦合实验实例中使用的模式分量实现及其连接方式和需要传输的数据结构。我们将同一模式分量实现的可能的不同使用方式配置放置于该文件下，如网格配置、单元比率配置、对外暴露的数据结构等。考虑到该文件作为耦合实验实例的主要描述文件，为确保其可读性，我们将其所有配置设为最简洁的短记录名引用方式，并在其他配置文件对这些短记录名进行注册。实际上，在所有耦合模式分量实现的初次配置完成后，仅通过修改该文件即可完成一个新实验实例的配置。

field.xml 文件描述了所有模式分量中存在的数据结构，将其所有可能存在的输入和输出全部记录。这样确保了一旦一个新的数据被注册后， field.xml 只需被修改一次，之后直接在 setup.xml 对其需要的数据传输进行针对不同实验实例的配置即可。此外，为了保证配置文件的简洁性，在该文件中所有的数据结构均以( 短记录名，全名，标准记录名，单位 )的四元组进行记录，并在其他配置文件中统一使用短记录名以精简配置文件，提高可读性。

regriddingFile.xml 文件描述了所有不同网格间进行转换时的插值矩阵。需要注意的是部分模式分量的只读参数和读写参数的插值矩阵不同(这可能是因为读写参数和只读参数的误差累积不同因此需要不同精度的插值矩阵)，因此这里进行分别配置。

camDesc.xml 这一类文件是单个具体模式分量实现的配置文件，通常以“模式分量实现名+Desc.xml”的形式命名。与 CESM 的模式分量配置类似，该文件主要包括的三部分分别为模式分量实现所在路径，编译配置脚本 configure 及选项，运行时配置文件建立脚本 build-namelist 及选项。由于我们已经将 namelist 文件中大部分需要与其他模式分量实现进行关联的部分提取到其他配置文件并通过脚本生成模块进行配置，这里 namelist 文件剩余内容实质上可以嵌入模式分量实现中，保留该文件的原因是与 CESM 进行向下兼容，实际运行时部分条目会被其他配置文件覆盖。

fractionSet.xml 是专门处理关于网格中部分格子位于区域交界处因而在各个模型中分别占有一定比值的情况。模型中对于这些比值有特定的数据结构进行存储并已在 field.xml 中进行注册。这里将各个涉及到的数据结构的初始化库函数进行对应的注册，并按照不同比值类型进行分类以适配不同的封装方式。

还有部分配置文件描述了顶层耦合模型需要的部分运行配置信息，这些信息通常在不同实验实例和不同模式分量实现中不需要修改，可以看作耦合模型代码生成模块的部分内置参数。

代码生成模块自动生成的库函数文件会直接放入耦合内部运行库中一同编译，这导致在 baseCpl 目录下的耦合内部运行库中有相当的代码是会在每次生成中被覆盖的。实际上在调试流程中，可以选择先在 baseCpl 目录下进行修改单个模式分量实现相关代码，并直接从耦合内部库的步骤开始编译，若能够通过则修改代码生成模块的模板或参数使其能够将同类代码全部自动生成为正确版本。另外，对于确定构成的数据结构，我们通常将其定义部分不经过代码生成模块直接写入耦合内部库，减少调用时可能出现的问题；对于不确定构成的数据结构则可以通过先进行初步模板生成作为参照接口来编写对应调用代码，最后再完善生成模块成为一套完整的接口。

顶层耦合模块和模式分量实现的接口沿用了 CESM 中每个耦合模式分量的 cpl\_mct 接口，一般分为 init ， run ， final 三个函数接口，参数确定为对应模式分量可见的耦合器部分数据结构、耦合器主要控制接口、已被适配和分辨率转换后的全部输入数据依赖、输出该模式分量自身格式的全部待传输数据、以及错误代码。在最终生成的耦合器主驱动代码中，默认设定为每个 init 方法依次调用，每当时钟跳变时都会调用 run 方法，让模式分量自行根据已设定的时钟进行检测并运行(此种设计可以提供更加开放的运行条件，如误差判定触发的运行等)。对于部分特殊的运行顺序需求可以直接在模板中进行追加配置(如 cam 的 init 方法需要重复调用等)。该接口在保留了封装和隔离的情况下尽可能地提高了模式分量实现的灵活性。

\subsection{调试环境}

在复现工程开始时，耦合平台只有代码生成模块具有较为完整的实现，内部库函数存在未实现或未测试的实现等问题。因此，一套能够对实例错误进行分析定位的工具是必要的，同时这类工具也能在未来可能出现的耦合器更新后产生的适配问题中进行辅助调试从而减轻工作量。为了设计出这样一套工具，我们需要预先确认耦合平台代码编译运行流程中的调试环境。

用户提供的 xml 配置文件通过代码生成模块进行解析。这里 parser 模块内的开源工具 ElementTree 提供了一定的语法检查功能，但对于语义检查需要耦合器的代码生成模块进行处理。代码生成的 ir 模块通过注册字典的方式实现了部分错误处理和检索数据结构建立，若成功完成即可在其他模块发生错误时通过预存的检索表有效定位到出错的数据所在的配置文件中。配置文件解析完毕后通过模板生成代码自身没有语法检查功能，而且是 python 脚本生成 fortran 代码，存在较大量的语义语法转换问题，这里的错误检查放到 baseCpl 整体编译时与预置库函数一同处理。

在第一步代码生成完成运行后， baseCpl 目录下的全部依赖满足，进行内部库预编译。内部库中存在部分预置调试信息，这些调试信息通常位于代码生成模块以外的预置库函数，若与模型实例相关，需要由代码生成模块生成调试信息打印代码，而这部分代码自身没有错误检测。部分针对性的调试信息可以在代码生成模块运行完毕后对生成后代码进行修改添加调试信息，但这些调试信息将会在下一次代码生成模块运行时被覆盖，因而不必插入调试开关，可以无条件打印调试信息。编译中若产生接口不匹配等问题也可以通过直接修改生成代码进行调试，通过后再反馈回代码生成模块进行模板修正。出现对外部库依赖的问题则可以考虑对 depUtils 的外部库进行打开调试开关的重编译进行调试。在这一步编译的过程中是不涉及 models 内代码的，因而可以实现顶层耦合与模式分量的隔离。

整个 baseCpl 目录预编译完成后即可生成运行实例，这也是在本次复现工作中主要的调试环境，其结构大致如下：

conf 目录存放需要用到的 configure 输出文件，这些文件在 CESM 代码中作为运行时配置文件存放，这里保留其兼容性，但代码生成部分的数据会自动将其覆盖。事实上，部分固定运行配置我们直接放入 BCGen 目录下的 inputdata 目录以直接快速调用，这一部分配置文件在确定正确后不必进行修改可以直接调用，减少调试复杂度。

doc 目录存放与运行无关的实验实例描述文件，主要描述生成该实例的代码位置和生成方法以便于复现。

include 目录存放预编译库的 .mod 文件。这些文件类似于 C 语言的头文件，作为编译各个模式分量实现的依赖。所有的 .mod 文件被平铺在该目录下，然后该目录被固定加入 INCLUDE\_PATH 以达成自动引入内部预置库的效果。需要注意的是由于预置库全部为直接引用，因此不能存在重名模块，否则可能会产生覆盖错误。

lib 目录存放预编译库的 .o 文件和各个模式分量实现编译完成的 .a 文件。初始时只有预编译库的 .o 文件，在各个模式分量实现分别利用 include 目录下的 .mod 文件编译完成后，会将该实现的源码编译结果打包为静态库放入该目录下。全部编译完成后，利用 cpl 耦合器核心代码链接全部这些静态库和预编译库，生成可执行文件。由于各个模式分量实现分别作为静态库打包，可以达成代码隔离，一定程度上避免了模式分量实现间可能出现的冲突问题。

models 目录存放所有的模式分量实现和 cpl 耦合器核心代码。这里同样是保留对 CESM 的兼容，使得 cpl 耦合器核心代码可以被其他模式分量实现在同层调用。各个模式分量实现的代码被直接拷贝到该目录下进行现场编译，因而可以在此目录下直接插入调试信息，在实验实例更新时直接进行覆盖。如果某个模式分量实现确认正确无需修改，即可在该目录下预编译后将打包后的 .a 文件缓存于对应模式分量实现路径下，在依赖库也不发生改变的情况下直接跳过编译阶段提高调试效率。

scripts 目录存放直接从顶层耦合目录 baseCpl 更新内置依赖库的脚本。它不会改变所有模式分量实现的状态，因而可以在调试过程中对内置依赖库进行快速的修正和更新以及调试信息附加等操作。其他相关脚本也要求放置在该目录下进行运行以确保相对路径的正确性。

src 目录存放部分模式分量实现需要共享的参数，这里主要是为了解决 mapper 模块带来的差值矩阵往返插值必须对应的问题，在 mapper.rc 文件中预设所有的差值矩阵，各个模式分量实现直接用该文件进行调用以确保匹配防止出现数值异常(由此原因导致的数值异常若恰好格式相同则较为隐蔽难以发现，故采用此种方式原生解决)。

代码目录只有 models 一个文件夹，其中 cpl 目录以外的全部为各个模式分量实现，我们将会在后面的章节详细介绍这些模式分量实现的封装、编译和调试流程。 cpl 目录包含核心运行代码 baseCpl.F90 ，该文件设定为通过模板自动生成，同时也是动态调试的核心代码(该代码插入调试信息后可以通过自动生成覆盖，因而可以在调试过程中任意修改)。其将所有的模式分量实现的每一步调用、数据交换的每一步插值和适配操作、历史纪录和存储恢复的每一次检查均作为独立的代码并进行了尽可能的封装和精简，原生支持插入任意形式的调试信息。这也是我们对整个模型进行错误定位的核心。该目录作为调试时的编译目录同样会记录各个模型的日志和缓存文件等，可以直接用 NetCDF 等外部工具进行读取和修改，从而可以较为方便地复现一些实际运行中较少出现的边界情况来进行特化调试。

\subsection{小结}

在本章内，我们介绍了复现 F2000 实验所基于的实验平台和代码框架，并着重讲述了其调试环境和调试工具的实现细节，为后续模式分量实现的适配和调试提供了基础。
